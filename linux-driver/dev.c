/*
 * Bare-bones SGX EPC driver. Exposes ENCLS pretty much directly to userspace.
 * Not intended for production use.
 *
 * (C) Copyright 2015 Jethro G. Beekman
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; version 2
 * of the License.
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/notifier.h>
#include <linux/kdebug.h>
#include <linux/ktime.h>
#include <linux/slab.h>
#include <linux/vmalloc.h>
#include <asm/asm.h>
#include <asm/traps.h>
#include <asm/uaccess.h>

#include "sgx.h"
#include "ioctl.h"

// ===global state===
static int major;
static void* epcmem;

// TODO: get this information from CPUID 0x12/ACPI device INT0E0C
static inline unsigned long epc_start(void) { return 0x80200000UL; }
static inline unsigned long epc_len(void) { return 0x05d80000UL; }

// ===ENCLS call architecture===

// The ENCLS call is guarded to gracefully stop exceptions. This is built on
// the die_notifier primitives. Fixups can't be used since there is no way to
// distinguish between exception types. There is only a single instance of the
// ENCLS opcode, defined in encls.S. The notifier callback checks if the
// exception was generated by that instructions address. If so, execution is
// resumed at the next instruction.

extern void encls_might_fault;
extern void encls_after_fault;

static struct {
	int trapnr;
	long error_code;
	unsigned long cr2;
	unsigned long reason;
	int triggered;
} die_info;

static int sgx_die_notify(struct notifier_block *, unsigned long, void *);
static struct notifier_block sgx_die_notifier = {
	.notifier_call = sgx_die_notify,
};

static int sgx_die_notify(struct notifier_block *nb, unsigned long event, void *_die_args)
{
	struct die_args *die_args = _die_args;

	unsigned long cr2=read_cr2();
	//printk("[SGX] trap event=%lu trap=%u func=%p IP=%p cr2=%016lx\n",event,die_args->trapnr,&encls_might_fault,(void*)die_args->regs->ip,cr2);
	if (!die_info.triggered && &encls_might_fault==(void*)die_args->regs->ip) {
		die_args->regs->ip=(long)&encls_after_fault;
		die_info.trapnr=die_args->trapnr;
		die_info.error_code=die_args->err;
		die_info.reason=event;
		die_info.cr2=cr2;
		die_info.triggered=1;
		return NOTIFY_STOP;
	}

	return NOTIFY_DONE;
}

// ===IOCTL===

// We need to copy structures out of user space before executing ENCLS. Offsets
// to fit everything in a single page with proper alignment:
//   struct      size   align   offset
//   SIGSTRUCT   1808   4096    0
//   (empty)     16             1808
//   PAGEINFO    32     32      1824
//   SECINFO     64     64      1856
//   PCMD        128    128     1920
//   EINITTOKEN  304    512     2048
//   (empty)     1744           2352
#define SIGSTRUCT_OFFSET   0
#define PAGEINFO_OFFSET    1824
#define SECINFO_OFFSET     1856
#define PCMD_OFFSET        1920
#define EINITTOKEN_OFFSET  2048

static unsigned long sgx_copy(unsigned long* pageptr,unsigned long offset,unsigned long src,unsigned long size) {
	unsigned long dst;
	if (!*pageptr)
		*pageptr=__get_free_page(GFP_KERNEL);
	if (!*pageptr)
		return 0;
	dst=(*pageptr)+offset;
	if (copy_from_user((void*)dst,(void*)src,size)!=0)
		return 0;
	return dst;
}

static long do_encls_ioctl(int leaf, struct sgx_ioctl_data* data, bool manage_die_notifier) {
	long ret=-EFAULT;
	long result,result_rbx;
	long page1=0,page2=0;
	ktime_t start1,start2,end1,end2;
	pageinfo_t* pageinfo;
	unsigned long user_rbx;

	switch (leaf) {
		case ENCLS_ECREATE:
		case ENCLS_EADD:
		case ENCLS_EDBGRD:
		case ENCLS_EDBGWR:
		case ENCLS_EEXTEND:
		case ENCLS_EINIT:
		case ENCLS_EREMOVE:
		case ENCLS_EBLOCK:
		case ENCLS_ETRACK:
		case ENCLS_ELDB:
		case ENCLS_ELDU:
		case ENCLS_EWB:
		case ENCLS_EPA:
			break;
		default:
			return -EINVAL;
	}

	start1=ktime_get_raw();
	if (leaf==ENCLS_ECREATE || leaf==ENCLS_EADD || leaf==ENCLS_ELDB || leaf==ENCLS_ELDU) {
		pageinfo=(pageinfo_t*)(data->rbx=sgx_copy(&page1,PAGEINFO_OFFSET,data->rbx,sizeof(pageinfo_t)));
		if (!pageinfo)
			goto exit;
		if (leaf==ENCLS_ECREATE || leaf==ENCLS_EADD)
			pageinfo->secinfo=sgx_copy(&page1,SECINFO_OFFSET,pageinfo->secinfo,sizeof(secinfo_t));
		else /* leaf==ENCLS_ELDB || leaf==ENCLS_ELDU */
			pageinfo->secinfo=sgx_copy(&page1,PCMD_OFFSET,pageinfo->secinfo,sizeof(pcmd_t));
		pageinfo->srcpge=sgx_copy(&page2,0,pageinfo->srcpge,4096);
		if (!pageinfo->secinfo || !pageinfo->srcpge)
			goto exit;
	} else if (leaf==ENCLS_EINIT) {
		data->rbx=sgx_copy(&page1,SIGSTRUCT_OFFSET,data->rbx,sizeof(sigstruct_t));
		data->rdx=sgx_copy(&page1,EINITTOKEN_OFFSET,data->rdx,sizeof(einittoken_t));
		if (!data->rbx || !data->rdx)
			goto exit;
	} else if (leaf==ENCLS_EWB) {
		page1=__get_free_page(GFP_KERNEL);
		page2=__get_free_page(GFP_KERNEL);
		if (!page1 || !page2)
			goto exit;
		user_rbx=data->rbx;
		pageinfo=(pageinfo_t*)(data->rbx=page1+PAGEINFO_OFFSET);
		pageinfo->secinfo=page1+PCMD_OFFSET;
		pageinfo->srcpge=page2;
		pageinfo->secs=0;
		pageinfo->linaddr=0;
	}
	end1=ktime_get_raw();

	//printk("[SGX] encls[%d] rcx=%p rbx=%p rdx=%p\n",leaf,(void*)data->rcx,(void*)data->rbx,(void*)data->rdx);
	die_info.triggered=0;
	if (manage_die_notifier) {
		unregister_die_notifier(&sgx_die_notifier);
		register_die_notifier(&sgx_die_notifier);
	}
	start2=ktime_get_raw();
	asm volatile("    call encls_might_fault \n"
				 : "=a"(result), "=b"(result_rbx)
				 : "a"(leaf), "b"(data->rbx) , "c"(data->rcx) , "d"(data->rdx)
				 : );
	end2=ktime_get_raw();
	if (manage_die_notifier)
		unregister_die_notifier(&sgx_die_notifier);
	if (die_info.triggered) {
		data->exception=die_info.trapnr;
		if (die_info.trapnr==X86_TRAP_PF)
			data->data=die_info.cr2;
		else if (die_info.trapnr==X86_TRAP_GP)
			data->data=die_info.error_code;
	} else {
		data->exception=-1;
		switch (leaf) {
			case ENCLS_EDBGRD:
				result=result_rbx;
				break;
			case ENCLS_EADD:
			//case ENCLS_EAUG: /*SGX2*/
			case ENCLS_ECREATE:
			case ENCLS_EDBGWR:
			case ENCLS_EEXTEND:
			case ENCLS_EPA:
			// NB: EREMOVE does modify EAX, unlike operand encoding table suggests
				result=0;
		}
		data->data=result;
	}

	if (leaf==ENCLS_EWB && data->exception==-1) {
		pageinfo_t user_pageinfo;
		start1=ktime_get_raw();
		copy_from_user(&user_pageinfo,(void*)user_rbx, sizeof(pageinfo_t));
		user_pageinfo.linaddr=pageinfo->linaddr;

		if (copy_to_user((void*)user_pageinfo.srcpge,(void*)pageinfo->srcpge,4096)!=0)
			goto exit;
		if (copy_to_user((void*)user_pageinfo.secinfo,(void*)pageinfo->secinfo,sizeof(pcmd_t))!=0)
			goto exit;
		if (copy_to_user((void*)user_rbx,&user_pageinfo,sizeof(pageinfo_t))!=0)
			goto exit;
		end1=ktime_get_raw();
	}

	data->duration_copy=end1.tv64-start1.tv64;
	data->duration_encls=end2.tv64-start2.tv64;

	ret=0;
exit:
	if (page1) free_page(page1);
	if (page2) free_page(page2);
	return ret;
}

static long sgxdev_ioctl(struct file *filep, unsigned int cmd, unsigned long arg) {
	switch (cmd) {
		case ENCLS_ECREATE_IOCTL:
		case ENCLS_EADD_IOCTL:
		case ENCLS_EDBGRD_IOCTL:
		case ENCLS_EDBGWR_IOCTL:
		case ENCLS_EEXTEND_IOCTL:
		case ENCLS_EINIT_IOCTL:
		case ENCLS_EREMOVE_IOCTL:
		case ENCLS_EBLOCK_IOCTL:
		case ENCLS_ETRACK_IOCTL:
		case ENCLS_ELDB_IOCTL:
		case ENCLS_ELDU_IOCTL:
		case ENCLS_EWB_IOCTL:
		case ENCLS_EPA_IOCTL: {
			long ret;
			struct sgx_ioctl_data data;

			if (copy_from_user(&data, (void*)arg, sizeof(data))!=0)
				return -EFAULT;

			ret=do_encls_ioctl(_IOC_NR(cmd),&data,1);

			if (copy_to_user((void*)arg,&data,sizeof(data))!=0)
				return -EFAULT;

			return ret;
		}
		case SGX_IOADDR_IOCTL: {
			struct sgx_ioctl_data data={
				.exception=-1,
				.data=(unsigned long)epcmem,
			};
			if (copy_to_user((char*)arg,&data,sizeof(data))!=0)
				return -EFAULT;
			return 0;
		}
		case SGX_MULTI_ENCLS_IOCTL: {
			long i;
			struct sgx_ioctl_vec vec;
			struct sgx_ioctl_vec_elem* ioctls=NULL;

			if (copy_from_user(&vec, (void*)arg, sizeof(vec))!=0)
				return -EFAULT;
			if (vec.num<0)
				return -EINVAL;
			ioctls=vmalloc(sizeof(struct sgx_ioctl_vec_elem)*vec.num);
			if (!ioctls)
				return -ENOMEM;
			if (copy_from_user(ioctls, vec.ioctls, sizeof(struct sgx_ioctl_vec_elem)*vec.num)!=0) {
				i=-EFAULT;
				goto exit;
			}

			unregister_die_notifier(&sgx_die_notifier);
			register_die_notifier(&sgx_die_notifier);

			for (i=0;i<vec.num;i++) {
				int flags=0;
				long ret=do_encls_ioctl(ioctls[i].leaf,&ioctls[i].data,0);
				if (ret) {
					i=ret;
					goto exit;
				}

				if (ioctls[i].data.exception!=-1) flags|=RETURN_EXCEPTION;
				if (ioctls[i].data.data!=ERR_SGX_NOERROR) {
					flags|=RETURN_ERROR;
					if (ioctls[i].data.data!=ERR_SGX_BLKSTATE) flags|=RETURN_ERROR_EBLOCK;
				}
				if (ioctls[i].return_flag&flags)
					break;
			}

			if (copy_to_user(vec.ioctls, ioctls, sizeof(struct sgx_ioctl_vec_elem)*vec.num)!=0) {
				i=-EFAULT;
				goto exit;
			}

exit:
			unregister_die_notifier(&sgx_die_notifier);
			vfree(ioctls);
			return i;

		}
		default:
			return -ENOTTY;
	}
}

// ===mmap===

static int sgxdev_mmap(struct file *filep, struct vm_area_struct *vma) {
	return vm_iomap_memory(vma,epc_start(),epc_len());
}

static unsigned long sgxdev_get_unmapped_area(struct file *filep, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags) {
	// make sure any map placed by the kernel is naturally aligned
	unsigned long area=current->mm->get_unmapped_area(filep,addr,len*2,pgoff,flags);
	if (IS_ERR_VALUE(area))
		return area;
	return (area+len)&~(len-1);
}

// ===module glue===

static struct file_operations fops = {
	.unlocked_ioctl = sgxdev_ioctl,
	.mmap = sgxdev_mmap,
	.get_unmapped_area = sgxdev_get_unmapped_area,
};

static int __init sgxdev_module_init(void) {
	major = register_chrdev(0, "sgxdev", &fops);
	if (major < 0) {
		printk ("[SGX] Registering the character device failed with %d\n", major);
		return major;
	}
	epcmem=ioremap_cache(epc_start(),epc_len());
	if (epcmem == NULL) {
		unregister_chrdev(major, "sgxdev");
		return -EBUSY;
	}
	printk("[SGX] create node with: sudo mknod -m 666 /dev/sgx c %d 0\n", major);
	return 0;
}

static void __exit sgxdev_module_exit(void) {
	iounmap(epcmem);
	unregister_die_notifier(&sgx_die_notifier);
	unregister_chrdev(major, "sgxdev");
	printk("[SGX] unloaded\n");
}

module_init(sgxdev_module_init);
module_exit(sgxdev_module_exit);
MODULE_LICENSE("GPL");
