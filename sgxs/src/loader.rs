/*
 * The Rust SGXS library.
 *
 * (C) Copyright 2016 Jethro G. Beekman
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 */

use std::io::{Error as IoError,Seek,SeekFrom};

use abi::{Sigstruct,Einittoken,Attributes};
use sgxs::SgxsRead;

pub use ::private::loader::Address;
pub use ::private::loader::Tcs;

pub trait Map: Drop {
	fn base_address(&self) -> Address;
	fn tcss(&mut self) -> &mut [Tcs];
}

pub trait Load<'dev> {
	type Mapping: Map + 'dev;
	type Error: EinittokenError + ::std::fmt::Debug;

	fn load<'r, R: SgxsRead + 'r>(&'dev self, reader: &'r mut R, sigstruct: &Sigstruct, einittoken: Option<&Einittoken>) -> Result<Self::Mapping,Self::Error>;

	fn load_with_launch_enclave<'e,'le,RE,RL>(&'dev self, enclave: &'e mut RE, enclave_sig: &Sigstruct, enclave_token: OptionalEinittoken, le: &'e mut RL, le_sig: &Sigstruct)
		-> Result<Self::Mapping,Error<Self::Error>> where RE: SgxsRead + Seek + 'e, RL: SgxsRead + 'le {
		use self::OptionalEinittoken as OptTok;

		let pos=match enclave.seek(SeekFrom::Current(0)) {
			Err(e) => { return Err(EnclaveSeek(e)) },
			Ok(p) => p,
		};

		match self.load(enclave,enclave_sig,enclave_token.as_option()) {
			Err(ref e) if e.is_einittoken_error() => {/*fall through to try new init token*/},
			Err(e) => { return Err(EnclaveLoad(e)) },
			Ok(m) => { return Ok(m) },
		};

		let mut save_token;
		let requested_attributes: Attributes;
		let token=match enclave_token {
			OptTok::None(None) => { requested_attributes=enclave_sig.attributes.clone(); save_token=Default::default(); &mut save_token },
			OptTok::None(Some(ref a)) | OptTok::Use(&Einittoken{attributes:ref a,..}) => { requested_attributes=a.clone(); save_token=Default::default(); &mut save_token },
			OptTok::Generate(t) | OptTok::UseOrGenerate(t) => { requested_attributes=t.attributes.clone(); *t=Default::default(); t },
		};

		try!(::intelcall::get_einittoken(self,enclave_sig,token,&requested_attributes,le,le_sig));

		if token.valid==0 {
			return Err(LaunchEnclaveNoToken);
		}

		match enclave.seek(SeekFrom::Start(pos)) {
			Err(e) => { return Err(EnclaveSeek(e)) },
			Ok(_) => {},
		};

		match self.load(enclave,enclave_sig,Some(&*token)) {
			Err(err) => Err(EnclaveLoad(err)),
			Ok(v) => Ok(v),
		}
	}
}

pub enum OptionalEinittoken<'a> {
	/// If an init token needed to be generated to load, it will be discarded
	/// after use. You can optionally specify the requested attributes,
	/// otherwise they will be taken from sigstruct.
	None(Option<Attributes>),
	/// If an init token needed to be generated to load, it will be written
	/// back here. The requested attributes will be taken from the attributes
	/// field, the rest of the input token is discarded.
	Generate(&'a mut Einittoken),
	/// Try to use the supplied init token. If it doesn't work, a new init
	/// token will be generated with the same attributes, and it will be
	/// discarded after use.
	Use(&'a Einittoken),
	/// Try to use the supplied init token. If it doesn't work, a new init
	/// token will be generated with the same attributes, and it will be
	/// written back here.
	UseOrGenerate(&'a mut Einittoken),
}

impl<'a> OptionalEinittoken<'a> {
	pub fn as_option(&self) -> Option<&Einittoken> {
		use self::OptionalEinittoken as OptTok;

		match self {
			&OptTok::None(_) | &OptTok::Generate(_) => None,
			&OptTok::Use(t) => Some(t),
			&OptTok::UseOrGenerate(ref t) => Some(&**t),
		}
	}
}

pub trait EinittokenError {
	/// Was this error generated by an invalid Einittoken?
	fn is_einittoken_error(&self) -> bool;
}

#[derive(Debug)]
pub enum Error<E: EinittokenError + ::std::fmt::Debug> {
	EnclaveLoad(E),
	EnclaveSeek(IoError),
	LaunchEnclaveLoad(E),
	LaunchEnclaveTcsCount,
	LaunchEnclaveInit(u64,u64),
	LaunchEnclaveGetToken(u64,u64),
	LaunchEnclaveNoToken,
}
use self::Error::*;
